Here's a modular C++ implementation of a quadtree for geospatial data, using latitude and longitude instead of Cartesian coordinates. Each component is placed in a separate file for better organization.

---

### **File Structure**
```
/quadtree
â”‚â”€â”€ main.cpp
â”‚â”€â”€ Point.h
â”‚â”€â”€ Point.cpp
â”‚â”€â”€ Node.h
â”‚â”€â”€ Node.cpp
â”‚â”€â”€ QuadTree.h
â”‚â”€â”€ QuadTree.cpp
```

---

## **1. `Point.h` (Geospatial Point Header)**
```cpp
#ifndef POINT_H
#define POINT_H

class Point {
public:
    double latitude;
    double longitude;

    Point(double lat, double lon);
    Point();
};

#endif
```

---

## **2. `Point.cpp` (Geospatial Point Implementation)**
```cpp
#include "Point.h"

Point::Point(double lat, double lon) : latitude(lat), longitude(lon) {}

Point::Point() : latitude(0.0), longitude(0.0) {}
```

---

## **3. `Node.h` (Node Header)**
```cpp
#ifndef NODE_H
#define NODE_H

#include "Point.h"

class Node {
public:
    Point location;
    int data;

    Node(Point loc, int data);
    Node();
};

#endif
```

---

## **4. `Node.cpp` (Node Implementation)**
```cpp
#include "Node.h"

Node::Node(Point loc, int d) : location(loc), data(d) {}

Node::Node() : location(Point()), data(0) {}
```

---

## **5. `QuadTree.h` (Quadtree Header)**
```cpp
#ifndef QUADTREE_H
#define QUADTREE_H

#include "Node.h"

class QuadTree {
private:
    Point topLeft;
    Point botRight;
    Node* n;
    QuadTree* topLeftTree;
    QuadTree* topRightTree;
    QuadTree* botLeftTree;
    QuadTree* botRightTree;

public:
    QuadTree(Point topL, Point botR);
    ~QuadTree();

    void insert(Node* node);
    Node* search(Point p);
    bool inBoundary(Point p);
};

#endif
```

---

## **6. `QuadTree.cpp` (Quadtree Implementation)**
```cpp
#include "QuadTree.h"
#include <iostream>
#include <cmath>

QuadTree::QuadTree(Point topL, Point botR)
    : topLeft(topL), botRight(botR), n(nullptr), topLeftTree(nullptr),
      topRightTree(nullptr), botLeftTree(nullptr), botRightTree(nullptr) {}

QuadTree::~QuadTree() {
    delete topLeftTree;
    delete topRightTree;
    delete botLeftTree;
    delete botRightTree;
}

// Check if point is inside boundary
bool QuadTree::inBoundary(Point p) {
    return (p.latitude >= topLeft.latitude && p.latitude <= botRight.latitude &&
            p.longitude >= topLeft.longitude && p.longitude <= botRight.longitude);
}

// Insert a node into the quadtree
void QuadTree::insert(Node* node) {
    if (!node || !inBoundary(node->location)) return;

    // If it's a leaf node and empty, store the node here
    if (!topLeftTree && !topRightTree && !botLeftTree && !botRightTree) {
        if (!n) {
            n = node;
        }
        return;
    }

    double midLat = (topLeft.latitude + botRight.latitude) / 2.0;
    double midLon = (topLeft.longitude + botRight.longitude) / 2.0;

    // Determine the quadrant for insertion
    if (node->location.latitude <= midLat) {
        if (node->location.longitude <= midLon) {
            if (!topLeftTree) topLeftTree = new QuadTree(topLeft, Point(midLat, midLon));
            topLeftTree->insert(node);
        } else {
            if (!topRightTree) topRightTree = new QuadTree(Point(topLeft.latitude, midLon), Point(midLat, botRight.longitude));
            topRightTree->insert(node);
        }
    } else {
        if (node->location.longitude <= midLon) {
            if (!botLeftTree) botLeftTree = new QuadTree(Point(midLat, topLeft.longitude), Point(botRight.latitude, midLon));
            botLeftTree->insert(node);
        } else {
            if (!botRightTree) botRightTree = new QuadTree(Point(midLat, midLon), botRight);
            botRightTree->insert(node);
        }
    }
}

// Search for a node in the quadtree
Node* QuadTree::search(Point p) {
    if (!inBoundary(p)) return nullptr;
    if (n) return n;

    double midLat = (topLeft.latitude + botRight.latitude) / 2.0;
    double midLon = (topLeft.longitude + botRight.longitude) / 2.0;

    if (p.latitude <= midLat) {
        if (p.longitude <= midLon && topLeftTree) return topLeftTree->search(p);
        if (topRightTree) return topRightTree->search(p);
    } else {
        if (p.longitude <= midLon && botLeftTree) return botLeftTree->search(p);
        if (botRightTree) return botRightTree->search(p);
    }

    return nullptr;
}
```

---

## **7. `main.cpp` (Test Driver)**
```cpp
#include "QuadTree.h"
#include <iostream>

int main() {
    // Define boundaries (latitude and longitude)
    QuadTree quadtree(Point(-90.0, -180.0), Point(90.0, 180.0));

    // Create some nodes with latitude and longitude
    Node a(Point(37.7749, -122.4194), 1); // San Francisco
    Node b(Point(34.0522, -118.2437), 2); // Los Angeles
    Node c(Point(40.7128, -74.0060), 3);  // New York

    // Insert nodes into the quadtree
    quadtree.insert(&a);
    quadtree.insert(&b);
    quadtree.insert(&c);

    // Search for a point
    Node* found = quadtree.search(Point(37.7749, -122.4194));
    if (found) {
        std::cout << "Found node with data: " << found->data << "\n";
    } else {
        std::cout << "Node not found\n";
    }

    found = quadtree.search(Point(34.0522, -118.2437));
    if (found) {
        std::cout << "Found node with data: " << found->data << "\n";
    } else {
        std::cout << "Node not found\n";
    }

    found = quadtree.search(Point(51.5074, -0.1278)); // London (Not inserted)
    if (found) {
        std::cout << "Found node with data: " << found->data << "\n";
    } else {
        std::cout << "Node not found\n";
    }

    return 0;
}
```

---

### **Key Modifications**
1. **Latitude & Longitude Support:**  
   - Modified `Point` to use `latitude` and `longitude` as `double` values.
   - Adjusted insert/search logic to work with real-world coordinates.
   
2. **Modular Structure:**  
   - Created separate `.h` and `.cpp` files for `Point`, `Node`, and `QuadTree`.

3. **Memory Management:**  
   - Added a destructor in `QuadTree` to clean up dynamically allocated memory.

4. **Test Data with Real Locations:**  
   - Inserted real latitude/longitude values (San Francisco, Los Angeles, New York).
   - Searched for a missing location (London).

This structure ensures clean, modular, and scalable code while supporting geospatial data efficiently! ðŸš€
